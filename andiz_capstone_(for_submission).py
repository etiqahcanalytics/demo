# -*- coding: utf-8 -*-
"""AndiZ Capstone (For Submission).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n6CiEpGJvqlopdobQJ8_J6qUt1eS5gE1
"""

# Commented out IPython magic to ensure Python compatibility.
#Import Packages
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns

#Load Data File
active_df = pd.read_excel('mydata.xlsx', sheet_name='ActiveList')
exit_df = pd.read_excel('mydata.xlsx', sheet_name='ExitList')

"""# Data Exploration

## Explore data using the following commands:
      a. .info ()
      b. Shape
      c. Head ()
"""

active_df.info()

active_df.shape

active_df.head()

exit_df.info()

exit_df.shape

exit_df.head()

"""## Explore Data Using SweetViz"""

#Explore using active_df

!pip install sweetviz
# Import SweetViz library
import sweetviz as sv

#Analyse the dataset
Overview_Active = sv.analyze(active_df)

#Display the report
Overview_Active.show_html('Overview.html')
Overview_Active.show_notebook()

# Explore using exit_df

!pip install sweetviz
# Import SweetViz library
import sweetviz as sv

#Analyse the dataset
Overview_Exit = sv.analyze(exit_df)

#Display the report
Overview_Exit.show_html('OverviewExit.html')
Overview_Exit.show_notebook()

#Drop Cost Centre Column
exit_df2 = exit_df.drop('COST CENTRE', axis=1)

exit_df2.info()

"""# Visualise data by answering the following questions:

1.   What is the total headcount per month?
2.   What is the average headcount per year?
3.   What is the total exit per month?
4.   What is the total exit per year?
5.   What is the attrition rate per month?
6.   What is the attrition rate per year?








"""

#What is the total headcount per month?

# Group the active DataFrame by year and month, and count the number of employee IDs for each group

grouped_active_df = active_df.groupby(['YEAR', 'MONTH NO']).agg({'PF NO': 'count'}).reset_index()
grouped_active_df = grouped_active_df.rename(columns={'PF NO': 'MONTHLY_HEADCOUNT'})
grouped_active_df = grouped_active_df.rename(columns={'MONTH NO': 'MONTH'})
print(grouped_active_df)

#What is the percentage increase of the total headcount from Jan FY2021 to Dec FY2022?

# Select the headcount for January 2021 and December 2022
jan_2021 = grouped_active_df.loc[(grouped_active_df['YEAR'] == 2021) & (grouped_active_df['MONTH'] == 1), 'MONTHLY_HEADCOUNT'].values[0]
dec_2022 = grouped_active_df.loc[(grouped_active_df['YEAR'] == 2022) & (grouped_active_df['MONTH'] == 12), 'MONTHLY_HEADCOUNT'].values[0]

# Print the selected values
print('Headcount for January 2021:', jan_2021)
print('Headcount for December 2022:', dec_2022)

#Calculate the percentage increase

HeadcountGrowthPerc = round((dec_2022 - jan_2021)/jan_2021*100,0)
print("Percentage Headcount Growth = ", HeadcountGrowthPerc)

#Another option to print percentage increase with the "%" symbol:

print("Percentage Headcount Growth = {:.0f}%".format(HeadcountGrowthPerc))

#Create an overlap chart to show headcount trend as follows:

sns.set_style("darkgrid")
plt.figure(figsize=(10,6))
sns.lineplot(x="MONTH", y="MONTHLY_HEADCOUNT", hue="YEAR", data=grouped_active_df)
plt.title("MAHB Group Workforce")
plt.xlabel("Month")
plt.ylabel("Number of Headcounts")
plt.show()

#What is the average headcount per year?

avg_2021_active = grouped_active_df[grouped_active_df['YEAR'] == 2021]['MONTHLY_HEADCOUNT'].mean().round(0)
avg_2022_active = grouped_active_df[grouped_active_df['YEAR'] == 2022]['MONTHLY_HEADCOUNT'].mean().round(0)
print('Average Headcount FY2021 =', avg_2021_active)
print('Average Headcount FY2022 =', avg_2022_active)

#What is the cumulative headcount per month to calculate the average by month and year
grouped_active_df['CUM_HEADCOUNT'] = grouped_active_df.groupby('YEAR')['MONTHLY_HEADCOUNT'].cumsum()

#Average Headcount By Month
grouped_active_df['AVG_HEADCOUNT'] = (grouped_active_df['CUM_HEADCOUNT'] / grouped_active_df['MONTH']).round(0)

print(grouped_active_df)

#What is the percentage increase of the average monthly headcount per year?

avg_headcount_perc =  (avg_2022_active - avg_2021_active) / avg_2021_active  * 100
print("Average Monthly Headcount Increase =", avg_headcount_perc.round(2))

#Another option to print percentage increase with the "%" symbol:

print("Average Monthly Headcount Increase = {:.0f}%".format(avg_headcount_perc))

#What is the total exit per month?

grouped_exit_df = exit_df.groupby(['YEAR', 'MONTH NO']).agg({'PF NO': 'count'}).reset_index()
grouped_exit_df = grouped_exit_df.rename(columns={'PF NO': 'MONTHLY_EXIT'})
grouped_exit_df = grouped_exit_df.rename(columns={'MONTH NO': 'MONTH'})

#Create a new column that shows cumulative exit by month, and grouped by Year.
grouped_exit_df['YTD EXIT'] = grouped_exit_df.groupby('YEAR')['MONTHLY_EXIT'].cumsum()
print(grouped_exit_df)

#Create an overlap chart to show Exit trend as follows:

sns.set_style("darkgrid")
plt.figure(figsize=(10,6))
sns.lineplot(x="MONTH", y="MONTHLY_EXIT", hue="YEAR", data=grouped_exit_df)
plt.title("MAHB Group Exits")
plt.xlabel("Month")
plt.ylabel("Number of Exits")
plt.show()

# What is the average and total exit per year?

avg_2021_exit = grouped_exit_df[grouped_exit_df['YEAR'] == 2021]['MONTHLY_EXIT'].mean().round(0)
avg_2022_exit = grouped_exit_df[grouped_exit_df['YEAR'] == 2022]['MONTHLY_EXIT'].mean().round(0)

print('Average Exits FY2021 =', avg_2021_exit)
print('Average Exits FY2022 =', avg_2022_exit)


total_2021_exit = grouped_exit_df[grouped_exit_df['YEAR'] == 2021]['MONTHLY_EXIT'].sum().round(0)
total_2022_exit = grouped_exit_df[grouped_exit_df['YEAR'] == 2022]['MONTHLY_EXIT'].sum().round(0)
print("\n")
print('Total Exits FY2021 =', total_2021_exit)
print('Total Exits FY2022 =', total_2022_exit)

#Creat a barplot for the Total Exits per year
bar_exit_data = [total_2021_exit, total_2022_exit]
years = ['2021', '2022']
colors = ['yellow', 'purple']


plt.bar(years, bar_exit_data, color=colors)
plt.title('Total Exits by Year')
plt.xlabel('Year')
plt.ylabel('Total Exits')
plt.show()

#Simplified version of the code above:

# Average exits by year
for year in [2021, 2022]:
    avg_exit = grouped_exit_df.loc[grouped_exit_df['YEAR'] == year, 'MONTHLY_EXIT'].mean().round(0)
    print(f"Average Exits FY{year} = {avg_exit}")

# Total exits by year
for year in [2021, 2022]:
    total_exit = grouped_exit_df.loc[grouped_exit_df['YEAR'] == year, 'MONTHLY_EXIT'].sum().round(0)
    print(f"Total Exits FY{year} = {total_exit}")

#Merge grouped_exit_df and grouped_active_df

merged_df = pd.merge(grouped_exit_df, grouped_active_df, on=['YEAR', 'MONTH'], how='left')
print(merged_df)

#Create a new dataframe that shows the year-to-date (YTD) attrition rate.

ytd_turnover_df = merged_df.loc[:, ('YEAR', 'MONTH','YTD EXIT','AVG_HEADCOUNT')]
ytd_turnover_df['YTD_ATTRITION_RATE (%)']= ytd_turnover_df['YTD EXIT']/ytd_turnover_df['AVG_HEADCOUNT']*100
print(ytd_turnover_df)

#Create a new dataframe that shows the monthly attrition rate.

mom_turnover_df = merged_df.loc[:, ('YEAR', 'MONTH','MONTHLY_EXIT','AVG_HEADCOUNT')]
mom_turnover_df['MOM_ATTRITION_RATE (%)']= mom_turnover_df['MONTHLY_EXIT']/ytd_turnover_df['AVG_HEADCOUNT']*100
print(mom_turnover_df)

#Plot the Monthly Attrition Rate to detect abnormality

import seaborn as sns
import matplotlib.pyplot as plt

sns.set(style="darkgrid")

# create the lineplot with hue
sns.lineplot(x="MONTH", y="MOM_ATTRITION_RATE (%)", hue="YEAR", data=mom_turnover_df)

# set the title and axis labels
plt.title("Monthly Attrition Rate by Year")
plt.xlabel("Month")
plt.ylabel("Attrition Rate (%)")

# display the plot
plt.show()

#Plot the Year-to-Date Attrition Rate to compare

import seaborn as sns
import matplotlib.pyplot as plt

sns.set(style="darkgrid")

# create the lineplot with hue
sns.lineplot(x="MONTH", y="YTD_ATTRITION_RATE (%)", hue="YEAR", data=ytd_turnover_df)

# set the title and axis labels
plt.title("YTD Attrition Rate by Year")
plt.xlabel("Month")
plt.ylabel("Attrition Rate (%)")

# display the plot
plt.show()

#Check whether there's any outlier for the Monthly Attrition Rate to detect abnormality

# First step is to prepare a new dataframe for easy reference
outlier_check = mom_turnover_df.loc[:, ('YEAR','MONTH', 'MOM_ATTRITION_RATE (%)',)]
outlier_check.head()

# Calculate the first and third quartiles of the 'MOM_ATTRITION_RATE (%)' column
q1 = outlier_check['MOM_ATTRITION_RATE (%)'].quantile(0.25)
q2 = outlier_check['MOM_ATTRITION_RATE (%)'].quantile(0.50)
q3 = outlier_check['MOM_ATTRITION_RATE (%)'].quantile(0.75)

# Calculate the interquartile range (IQR)
iqr = q3 - q1

# Define the lower and upper bounds beyond which values are considered outliers
lower_bound = q1 - 1.5 * iqr
upper_bound = q3 + 1.5 * iqr

# Identify potential outliers by checking which values fall outside the bounds
outliers = outlier_check[(outlier_check['MOM_ATTRITION_RATE (%)'] < lower_bound) | (outlier_check['MOM_ATTRITION_RATE (%)'] > upper_bound)]

# Print the potential outliers (if any)
if len(outliers) > 0:
    print("Potential outliers:")
    print(outliers)
else:
    print("No outliers found.")

#Print the values of each quantile, and the boxplot areas (iqr, lower bound and upper bound)
for value in (q1,q2, q3, iqr, lower_bound, upper_bound):
    print(round(value, 4))

#Visualise the 'MOM_ATTRITION_RATE (%)' data on a Box Plot to check for outliers

import matplotlib.pyplot as plt

# Create a box plot of the 'MOM_ATTRITION_RATE (%)' column
plt.boxplot(outlier_check['MOM_ATTRITION_RATE (%)'])

# Set the title and labels for the plot
plt.title("Box plot of 'MOM_ATTRITION_RATE (%)'")
plt.xlabel("MOM_ATTRITION_RATE (%)")
plt.ylabel("Value")

# Show the plot
plt.show()

# Average Headcount Boxplot
# prepare a new dataframe for easy reference
outlier_check2 = mom_turnover_df.loc[:, ('YEAR','MONTH','AVG_HEADCOUNT')]

# Calculate the first and third quartiles of the 'MONTHLY_EXIT' column
q1_avg = outlier_check2['AVG_HEADCOUNT'].quantile(0.25)
q2_avg = outlier_check2['AVG_HEADCOUNT'].quantile(0.50)
q3_avg = outlier_check2['AVG_HEADCOUNT'].quantile(0.75)

# Calculate the interquartile range (IQR)
iqr_avg = q3_avg - q1_avg

# Define the lower and upper bounds beyond which values are considered outliers
lower_bound_avg = q1_avg - 1.5 * iqr_avg
upper_bound_avg = q3_avg + 1.5 * iqr_avg

# Identify potential outliers by checking which values fall outside the bounds
outliers_avg = outlier_check2[(outlier_check2['AVG_HEADCOUNT'] < lower_bound_avg) | (outlier_check2['AVG_HEADCOUNT'] > upper_bound_avg)]

# Print the potential outliers (if any)
if len(outliers_avg) > 0:
    print("Potential outliers:")
    print(outliers_avg)
else:
    print("No outliers found.")

#Average Headcount Box Plot
#Print the values of each quantile, and the boxplot areas (iqr, lower bound and upper bound)
for value in (q1_avg, q2_avg, q3_avg, iqr_avg, lower_bound_avg, upper_bound_avg):
    print(round(value, 4))

#Since the formula for attrition rate it (Monthly Exit divided by Average Headcount), we need to ensure the components do not have any outliers.
#Therefore, we check the Boxplots for Monthly Exit and Average Headcount data

merged_df.boxplot(column=['AVG_HEADCOUNT'])

#Findings: There's no outlier

# Monthly Exit Boxplot
# prepare a new dataframe for easy reference
outlier_check2 = mom_turnover_df.loc[:, ('YEAR','MONTH','MONTHLY_EXIT')]

# Calculate the first and third quartiles of the 'MONTHLY_EXIT' column
q1_me = outlier_check2['MONTHLY_EXIT'].quantile(0.25)
q2_me = outlier_check2['MONTHLY_EXIT'].quantile(0.50)
q3_me = outlier_check2['MONTHLY_EXIT'].quantile(0.75)

# Calculate the interquartile range (IQR)
iqr_me = q3_me - q1_me

# Define the lower and upper bounds beyond which values are considered outliers
lower_bound_me = q1_me - 1.5 * iqr_me
upper_bound_me = q3_me + 1.5 * iqr_me

# Identify potential outliers by checking which values fall outside the bounds
outliers_me = outlier_check2[(outlier_check2['MONTHLY_EXIT'] < lower_bound_me) | (outlier_check2['MONTHLY_EXIT'] > upper_bound_me)]

# Print the potential outliers (if any)
if len(outliers_me) > 0:
    print("Potential outliers:")
    print(outliers_me)
else:
    print("No outliers found.")

#Monthly Exit Box Plot
#Print the values of each quantile, and the boxplot areas (iqr, lower bound and upper bound)
for value in (q1_me, q2_me, q3_me, iqr_me, lower_bound_me, upper_bound_me):
    print(round(value, 4))

merged_df.boxplot(column=['MONTHLY_EXIT'])

#Findings = There's no outliers

#What is the total exit per month and by division?

grouped_exit_div = exit_df.groupby(['DIVISION','YEAR']).agg({'PF NO': 'count'}).reset_index()
grouped_exit_div = grouped_exit_div.rename(columns={'PF NO': 'TOTAL_EXIT'})
grouped_exit_div = grouped_exit_div.rename(columns={'MONTH NO': 'MONTH'})

exit_div = grouped_exit_div.pivot(index='DIVISION', columns='YEAR', values='TOTAL_EXIT')
print(exit_div)

#Clean the Division output data to remove duplicates due to formatting error.
div_cleaned = exit_div.rename(index=str.title)
exit_div2 = div_cleaned.groupby(level=0).sum()
print(exit_div2)

#Find the total monthly average active headcount by division
grouped_active_div = active_df.groupby(['DIVISION', 'YEAR']).agg({'PF NO': lambda x: round(len(x)/12)}).reset_index()
grouped_active_div = grouped_active_div.rename(columns={'PF NO': 'AVG_HEADCOUNT'})
grouped_active_div = grouped_active_div.rename(columns={'MONTH NO': 'MONTH'})

active_div = grouped_active_div.pivot(index='DIVISION', columns='YEAR', values='AVG_HEADCOUNT')
print(active_div)

#Clean the Average Headcount by Division data to remove duplicates due to formatting error.
active_div_cleaned = active_div.rename(index=str.title)
active_div2 = active_div_cleaned.groupby(level=0).sum()
print(active_div2)

#Merge active_div2 and exit_div2

merged_div = pd.merge(active_div2, exit_div2, on=['DIVISION'], how='left', suffixes=('_Active', '_Exit'))
print(merged_div)

#Calculate Attrition Rate by Division
merged_div['2021_Att'] = merged_div['2021_Exit']/merged_div['2021_Active']
merged_div['2022_Att'] = merged_div['2022_Exit']/merged_div['2022_Active']
merged_div.fillna(0, inplace=True)

print(merged_div)

#Create New Dataframe that shows only Division and Attrition Rate by Year

att_div = merged_div[['2021_Att', '2022_Att']]
sorted_att1 = att_div.sort_values(by='2022_Att', ascending=False)
print(sorted_att1)

#Top 5 Attrition by Division in FY2021

sorted_att2 = sorted_att1.sort_values(by='2021_Att', ascending=False)
sorted_att2.head()

#Top 5 Attrition by Division in FY2022
sorted_att2 = sorted_att1.sort_values(by='2022_Att', ascending=False)
sorted_att2.head()

#Bottom 5 Attrition by Division in FY2021 with those zero values excluded
sorted_att2 = sorted_att1[sorted_att1['2021_Att']!=0].sort_values(by='2021_Att', ascending=False)
sorted_att2.tail()

#Bottom 5 Attrition by Division in FY2022 with those zero values excluded
sorted_att2 = sorted_att1[sorted_att1['2022_Att']!=0].sort_values(by='2022_Att', ascending=False)
sorted_att2.tail()

print(sorted_att1)

#Divisions with Zero Attrition Rates in FY2021

zero_att21 = sorted_att1[sorted_att1['2021_Att'] == 0]
zero_21 = zero_att21['2021_Att']
print(zero_21)

#Divisions with Zero Attrition Rates in FY2022

zero_att22 = sorted_att1[sorted_att1['2022_Att'] == 0]
zero_22 = zero_att22['2022_Att']
print(zero_22)

# create a bar plot
sorted_att1.plot(kind='bar', figsize=(12, 8))

# set the title and labels for the plot
plt.title('Attrition by Division in 2021 and 2022')
plt.xlabel('Division')
plt.ylabel('Attrition (%)')

# show the plot
plt.show()

# drop 'Chairman'S Office' row
sorted_att2 = sorted_att1.drop("Chairman'S Office")

# create a bar plot
sorted_att2.plot(kind='bar', figsize=(12, 8))

# set the title and labels for the plot
plt.title('Attrition by Division in 2021 and 2022')
plt.xlabel('Division')
plt.ylabel('Attrition (%)')

# show the plot
plt.show()

sorted_att1['Diff']=sorted_att1['2022_Att']-sorted_att1['2021_Att']
print(sorted_att1)

# Create a new dataframe called diff_att by dropping rows with a "Diff" value of 0
diff_att = sorted_att1.drop(sorted_att1[sorted_att1["Diff"] == 0].index)
print(diff_att)

# Create a new dataframe called diff_att2 by dropping the row for Chairman's Office
# and sort in an ascending order for 'Diff' column

diff_att2 = diff_att.drop("Chairman'S Office").sort_values(by='Diff', ascending=False)
print(diff_att2)

# create a bar plot of the "Diff" column
diff_att2["Diff"].plot(kind="bar")

# set the title and axis labels
plt.title("Difference Between 2021 and 2022")
plt.xlabel("Division")
plt.ylabel("Difference")

# show the plot
plt.show()